<html>

<head>
	
<style>
.selected {
	background-color: rgb(255,255,153);
}

#id_header {
	background-color: rgb(64,64,64);
	color: rgb(255,255,255);
	font-size: 75%;
	text-align: center;
}

#id_top {
	padding: 8;
}

#id_content {
	padding: 8;
}

input[type="text"], textarea {
	background-color : rgb(0,0,0); 
	color: rgb(255,255,255);
	font-size: 125%;
	border: 1px solid black;
}

button {
	background-color : rgb(0,0,0); 
	color: rgb(200,200,200);
	border: 1px solid black;
}

a {
	color: rgb(255,255,255);
	text-decoration: none !important;
}

body { font-family: sans-serif; }

.hidden { display: none; }

table.results {
	font-family:"Trebuchet MS", Arial, Helvetica, sans-serif;
	border-collapse:collapse;
	margin: 0 auto;
}
table.results td, table.results th {
	font-size:1em;
	padding:3px 7px 2px 7px;
}
table.results th {
	font-size:1.1em;
	padding-top:5px;
	padding-bottom:4px;
	background-color:#7FE57F;
	color:#000000;
}
table.results tr.odd {
	color:#000000;
	background-color:#EAF2D3;
}
table.results tr:hover {
	color:#000000;
	background-color:#FFFFCC;
}
table.results tr.odd:hover {
	color:#000000;
	background-color:#FFFFCC;
}

table.results td {
	border-top:1px solid #98BF21;
}

hr { clear: both; }
hr.invisible { clear: both; visibility: hidden; }

@media print { .noprint { display: none; } }

</style>
	
<script>
	
const contrastColour = 'rgb( 255, 130, 0 )';

function GetScaleRatio( wBitmap, hBitmap, width, height ) {
	return Math.min( width / wBitmap, height / hBitmap );
}

function intervalsOverlap( a0, a1, b0, b1 ) {
	return a0 <= b1 && b0 <= a1;
}

// A rectangle is an array [x, y, width, height].
// These convenience routines get the rectangle corners.
function topRight( r )		{ return [r[0] + r[2], r[1]]; }
function topLeft( r )		{ return [r[0], r[1]]; }
function bottomLeft( r ) 	{ return [r[0], r[1] + r[3]]; }
function bottomRight( r )	{ return [r[0] + r[2], r[1] + r[3]]; }

function intersectRect( a, b ) {
	// Return the intersection rectangle between the two given rectangles.
	// Returns an empty rectangle if there is no intersection.
	const x = Math.max(a[0], b[0]);
	const num1 = Math.min(a[0] + a[2], b[0] + b[2]);
	const y = Math.max(a[1], b[1]);
	const num2 = Math.min(a[1] + a[3], b[1] + b[3]);
	if (num1 >= x && num2 >= y)
		return [x, y, num1 - x, num2 - y];
	else
		return [0,0,0,0];
}

class ScaledBitmap {
	constructor( canvas, image=null, drawFinishLine=false, inset=true ) {
		this.canvas = canvas;
		this.SetImage( image );
		this.mouseButtonDown = false;
		this.background = 'rgb(232,232,232)';
		this.resetMagRect();
		canvas.addEventListener('resize', this.OnSize.bind(this) );

		this.drawFinishLine = drawFinishLine;
		
		this.eventCache = [];
		if( inset ) {
			canvas.addEventListener('pointerdown', this.OnPointerDown.bind(this), false);
			canvas.addEventListener('pointermove', this.OnPointerMove.bind(this), false);
			canvas.addEventListener('pointerup', this.OnPointerUp.bind(this), false);
			canvas.addEventListener('pointercancel', this.OnPointerUp.bind(this), false);
			canvas.addEventListener('pointerleave', this.OnPointerUp.bind(this), false);
		}
		this.Refresh();
	}
	
	resetMagRect() {
		this.beginX = 0;
		this.beginY = 0;
		this.endX = 0;
		this.endY = 0;
	}
	
	getMagRect() {
		return [Math.min(this.beginX, this.endX), Math.min(this.beginY, this.endY), Math.abs(this.endX-this.beginX), Math.abs(this.endY-this.beginY)];
	}
	
	OnSize( event ) {
		this.resetMagRect();
		this.Refresh();
	}
	
	OnPointerDown( event ) {
		if( event.pointerType == 'mouse' && (event.buttons != 1) )	// Ignore all mouse events except for left button.
			return;
		
		this.eventCache.push( event );
		if( this.eventCache.length == 1 ) {
			//console.log( 'OnPointerDown: initializing zoom' );
			this.beginX = this.endX = this.eventCache[0].offsetX;
			this.beginY = this.endY = this.eventCache[0].offsetY;
			this.Refresh();
			
			this.mouseButtonDown = (event.pointerType == 'mouse' && (event.buttons == 1));
			this.canvas.style.cursor = 'zoom-in';
		}
		else {
			//console.log( 'OnPointerDown: pinch zoom point' );
			this.OnPointerMove( event );
		}
	}
	
	OnPointerMove( event ) {
		const i = this.eventCache.findIndex( e => e.pointerId == event.pointerId );
		if( i >= 0 )
			this.eventCache[i] = event;
		
		if( this.eventCache.length == 1 ) {
			if( this.mouseButtonDown ) {
				//console.log( 'OnPointerMove: mouse expand zoom' );
				this.endX   = this.eventCache[0].offsetX;
				this.endY   = this.eventCache[0].offsetY;
				this.Refresh();
			}
		}
		else if( this.eventCache.length >= 2 ) {
			//console.log( 'OnPointerMove: pinch expand zoom' );
			this.beginX = this.beginY = Number.POSITIVE_INFINITY;
			this.endX   = this.endY   = Number.NEGATIVE_INFINITY;
			for( let i = 0; i < this.eventCache.length; ++i ) {
				const offsetX = this.eventCache[i].offsetX, offsetY = this.eventCache[i].offsetY;
				this.beginX  = Math.min( this.beginX, offsetX );
				this.beginY  = Math.min( this.beginY, offsetY );
				this.endX    = Math.max( this.endX,   offsetX );
				this.endY    = Math.max( this.endY,   offsetY );
			}
			this.Refresh();
		}
	}
	
	OnPointerUp( event ) {
		const i = this.eventCache.findIndex( e => e.pointerId == event.pointerId );
		if( i >= 0 )
			this.eventCache.splice(i, 1);
			
		if( this.eventCache.length == 0 ) {
			this.canvas.style.cursor = 'auto';
			this.mouseButtonDown = false;
		}
		else
			this.OnPointerMove( this.eventCache[0] );
	}
	
	getInsetRect( width, height, isWest, isNorth ) {
		const r = 0.75;
		const insetWidth = width*r, insetHeight = height*r;
		return [!isWest ? 0 : width - insetWidth, !isNorth ? 0 : height - insetHeight, insetWidth, insetHeight];
	}
	
	draw( dc, width, height ) {
		// Clear the canvas.
		dc.beginPath();
		dc.rect( 0, 0, width, height );
		dc.fillStyle = 'rgb(0,0,0)';
		dc.fill();
		
		if( !this.bitmap )
			return;
		
		// Draw the image in the canvas.
		let sourceBM = this.bitmap;
		const sourceWidth = sourceBM.width, sourceHeight = sourceBM.height;
		const ratio = GetScaleRatio( sourceWidth, sourceHeight, width, height );
		const destWidth = sourceWidth * ratio, destHeight = sourceHeight * ratio;

		const xLeft = Math.max(0, (width - destWidth)/2);
		const yTop = Math.max(0, (height - destHeight)/2);
		if( sourceWidth > 0 && sourceHeight > 0 && destWidth > 0 && destHeight > 0 )
			dc.drawImage( sourceBM, 0, 0, sourceWidth, sourceHeight, xLeft, yTop, destWidth, destHeight );
		
		if( this.drawFinishLine ) {
			dc.strokeStyle = contrastColour;
			dc.lineWidth = 1;
			dc.beginPath();
			dc.moveTo( width/2, 0 );
			dc.lineTo( width/2, height );
			dc.stroke();
		}
		
		const magnifyRect = this.getMagRect();
		if( magnifyRect[2] <= 0 || magnifyRect[3] <= 0 )
			return;
			
		const sourceRect = intersectRect(
			[0, 0, sourceWidth, sourceHeight],
			[(magnifyRect[0] - xLeft)/ratio, (magnifyRect[1]-yTop)/ratio, magnifyRect[2]/ratio, magnifyRect[3]/ratio]
		);
		
		if( sourceRect[2] <= 0 || sourceRect[3] <= 0 )
			return;
			
		const xCenter = sourceRect[0] + sourceRect[2] / 2, yCenter = sourceRect[1] + sourceRect[3] / 2;
		const isWest = xCenter < this.bitmap.width/2, isNorth = yCenter < this.bitmap.width/2;
		let insetRect = this.getInsetRect( width, height, isWest, isNorth );
		
		const magRatio = GetScaleRatio( sourceRect[2], sourceRect[3], insetRect[2], insetRect[3] );
		const iWidth = sourceRect[2] * magRatio, iHeight = sourceRect[3] * magRatio;
		insetRect = [
			insetRect[0] != 0 ? insetRect[0] + insetRect[2] - iWidth : 0,
			insetRect[1] != 0 ? insetRect[1] + insetRect[3] - iHeight : 0,
			iWidth, iHeight
		];
		
		dc.drawImage( sourceBM, ...sourceRect, ...insetRect );

		// Draw the outlines.
		dc.strokeStyle = 'rgb(200,200,0)';
		dc.lineWidth = 2;

		dc.beginPath();
		dc.rect( ...insetRect );
		dc.rect( ...magnifyRect );
		dc.stroke();
		
		// Draw the direction lines.
		function drawLine( p1, p2 ) {
			dc.moveTo( ...p1 );
			dc.lineTo( ...p2 );
		}
				
		if( intervalsOverlap(magnifyRect[0], magnifyRect[0] + magnifyRect[2], insetRect[0], insetRect[0] + insetRect[2]) ) {
			if( intervalsOverlap(magnifyRect[1], magnifyRect[1] + magnifyRect[3], insetRect[1], insetRect[1] + insetRect[3]) )
				return;
				
			dc.beginPath();
			if( isNorth ) {
				drawLine( bottomLeft(magnifyRect), topLeft(insetRect) );				
				drawLine( bottomRight(magnifyRect), topRight(insetRect) );
			}
			else {
				drawLine( topLeft(magnifyRect), bottomLeft(insetRect) );
				drawLine( topRight(magnifyRect), bottomRight(insetRect) );
			}
			dc.stroke();
		}
		else {
			dc.beginPath();
			if( isWest ) {
				drawLine( topRight(magnifyRect), topLeft(insetRect) );
				drawLine( bottomRight(magnifyRect), bottomLeft(insetRect) );
			}
			else {
				drawLine( topLeft(magnifyRect), topRight(insetRect) );
				drawLine( bottomLeft(magnifyRect), bottomRight(insetRect) );
			}
			dc.stroke();
		}
	}
	
	SetImage( image ) {
		this.bitmap = null;
		if( image ) {
			this.bitmap = new OffscreenCanvas( image.width, image.height );
			let dc = this.bitmap.getContext('2d');
			dc.drawImage( image, 0, 0, image.width, image.height, 0, 0, image.width, image.height );
			this.Refresh()
		}
	}
	
	SetToEmpty() {
		const width = this.canvas.width, height = this.canvas.height;
		this.bitmap = new OffscreenCanvas( width, height );
		let ctx = this.bitmap.getContext('2d');
		ctx.beginPath();
		ctx.rect( 0, 0, width, height );
		ctx.fillStyle = 'rgb(255,255,255)';
		ctx.fill();
		this.Refresh()
	}
		
	SetTestBitmap() {
		// Draw a test pattern into the offscreen bitmap.
		const width = this.canvas.width, height = this.canvas.height;
		this.bitmap = new OffscreenCanvas( width, height );
		let dc = this.bitmap.getContext('2d');
		
		let colours = [
			'rgb(255,255,255)', 'rgb(255,0,0)', 'rgb(0,255,0)', 'rgb(0,0,255)',
			'rgb(255,255,0)', 'rgb(255,0,255)', 'rgb(0,255,255)', 'rgb(0,0,0)'
		];
		let x, y;
		const rWidth = width / colours.length;
		for( let row = 0; row < 2; ++row ) {
			y = (row == 0 ? 0 : height * 0.75);
			let hCur = (row == 0 ? height * 0.75 : height * 0.25);
			for( let col = 0; col < colours.length; ++col ) {
				dc.beginPath();
				dc.rect( rWidth * col, y, rWidth+1, hCur );
				dc.fillStyle = colours[col];
				dc.fill();
			}
			colours.reverse();
		}
		
		const r = Math.min(width, height) / 3;
		x = width / 2;
		y = height / 2;
		const angle = 2.0*Math.PI / colours.length;
		for( let i = 0; i < colours.length; ++i ) {
			dc.beginPath();
			dc.moveTo( x, y );
			dc.lineTo( x + r * Math.cos(angle*i), y + r * Math.sin(angle*i) );
			dc.arc( x, y, r, angle*i, angle*(i+1), false);
			dc.closePath();
			dc.fillStyle = colours[i];
			dc.fill();
		}
		
		this.Refresh();
	}
	
	Refresh() {
		this.draw( this.canvas.getContext('2d'), this.canvas.width, this.canvas.height );
	}
};

var scaledBitmap = null;
var matched = [];
var iSelected = 0;

function select_row( iRow ) {
	let table = document.getElementById( 'id_info' );
	
	for( let i = 0; i < matched.length; ++i ) {
		let td = document.getElementById( 'ir' + i );
		if( td.classList.contains('selected') ) {
			td.classList.remove('selected');
			break;
		}
	}

	iSelected = iRow;
	if( iSelected < matched.length ) {
		img = new Image();
		img.addEventListener('load', () => scaledBitmap.SetImage(img) );
		img.src = matched[iSelected]['photo'];
		document.getElementById( 'ir' + iSelected ).classList.add('selected');
	}
	else
		scaledBitmap.SetTestBitmap();
	
}

function secondsToStr( s ) {
	s = Math.floor( s );
	hh = Math.floor(s / (60*60));
	mm = Math.floor(s / 60) % 60;
	ss = s % 60;
	return hh + ':' + (mm < 10 ? '0' : '') + mm + ':' + (ss < 10 ? '0' : '') + ss;
}

function do_search() {
	const search_text = document.getElementById('id_search').value.trim().toLowerCase();
	
	matched = [];
	if( search_text ) {	
		const attrs = ['bib', 'first_name', 'last_name', 'team'];
		for( const info of photo_info ) {
			for( const a of attrs ) {
				if( (info[a] + '').toLowerCase().includes( search_text ) ) {
					matched.push( info )
					break;
				}
			}
		}
	}
	else
		matched = photo_info;
	
	let table = document.getElementById( 'id_info' );
	table.innerHTML = "";
	let thead = document.createElement( 'thead' );
	table.appendChild( thead );
	let tr = document.createElement( 'tr' );
	thead.appendChild( tr );
	const headers = ['', 'Bib', 'First Name', 'Last Name', 'Team', 'Time', 'Time of Day', 'Race'];
	for( const h of headers ) {
		let th = document.createElement('th');
		th.appendChild( document.createTextNode(h) );
		thead.appendChild( th );
	}
	let tbody = document.createElement( 'tbody' );
	table.appendChild( tbody );
	const attrs = ['bib', 'first_name', 'last_name', 'team', 'raceSeconds', 'ts', 'race_name'];
	for( let i = 0; i < matched.length; ++i ) {
		const info = matched[i];
		let tr = document.createElement( 'tr' );
		tr.id = 'ir' + i;
		tr.onclick = function( iRow ) { return function() { select_row(iRow); } }( i );
		tbody.appendChild( tr );

		// Add a row number.
		let td = document.createElement( 'td' );
		td.style.textAlign = 'right';
		td.appendChild( document.createTextNode( (i+1) + '.') );
		tr.appendChild( td );

		for( const attr of attrs ) {
			let td = document.createElement( 'td' );
			if( attr == 'bib' || attr == 'ts' || attr == 'raceSeconds' )
				td.style.textAlign = 'right';
			let value = info[attr];
			if( value ) {
				if( attr == 'raceSeconds' )
					value = secondsToStr( value );
				else if( attr == 'ts' )
					value = value.split('T')[1].replace( /\.[0-9]+$/, '' );
			}
			td.appendChild( document.createTextNode(value ? value : '') );
			tr.appendChild( td );
		}
	}

	select_row( 0 );
}

var photo_info = [];	// Populated by CrossMgrVideo.

function onload() {
	let canvas = document.getElementById( 'id_canvas' );
	scaledBitmap = new ScaledBitmap( canvas, null );
	scaledBitmap.SetTestBitmap();
	
	function do_resize( event ) {
		canvas.width = Math.max( 32, window.innerWidth - 32 );
		canvas.height = Math.max( 32, window.innerHeight * 2/3 );
		scaledBitmap.OnSize();
	}
	do_resize( null );
	window.addEventListener('resize', do_resize );
	do_search();
}
	
</script>
</head>
<body onload="onload();">
	<div id="id_header">
		<div id="id_top">
			<img style="vertical-align: text-bottom;" src="data:image/png;base64,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" />
			<a href="http://www.sites.google.com/site/crossmgrsoftware"><span style="font-size: 175%"><strong>CrossMgr</strong></span></a>&nbsp;&nbsp;&nbsp;&nbsp;
			<input type="text" id="id_search" placeholder="Search Bib, Name, Team" size="32" oninput="do_search();">&nbsp;&nbsp;&nbsp;&nbsp;
			Click and Drag in Photo to Zoom.
		</div>
		<canvas id="id_canvas"></canvas>
	</div>
	<div id="id_content">
		<table id="id_info" class="results"></table>
	</div>
</body>
